#+TITLE: cite:ward2014linux: How linux works: what every superuser should know
#+ROAM_KEY: cite:ward2014linux

- tags :: [[file:learn_linux_101_streams_pipes_and_redirects_build_smart_build_secure_ibm_developer.org][Learn Linux, 101: Streams, pipes, and redirects – Build Smart. Build Secure. IBM Developer]]

*  Notes
:PROPERTIES:
:Custom_ID: ward2014linux
:NOTER_DOCUMENT: %(orb-process-file-field "ward2014linux")
:AUTHOR: Ward, B.
:JOURNAL:
:DATE:
:YEAR: 2014
:DOI:
:URL:
:END:

* txt structure
*** Chap 1 - Quadro geral
*** Chap 2 - Comandos básicos e hierarquia de diretórios
p*** Chap 3 - Dispositivos

* Sonke questions
Those are questions that aim to connect the notes with other notes and with
projects.

** What is it about ?
** What does it mean for ...?
** How does the new information contradict, correct, support, or add to what I already know?
** How can I combine ideas to generate something new?
** What questions are triggered by these new ideas?

* Struct questions

** What is the goal of the text?
** What is the general argument of the text?
** What are the specific arguments of the text?
*** Chap 1 - Quadro geral

- That an OS is based upon abstraction

- That linux is organized in three layers:
  - hardware
  - kernel
  - user space

- That the kernel and the user space execute in different modes

- That an user process is more limited in the damage it can cause to the system (it shouldn't cause any damage)

- That the kernel is responsible for managing 4 areas of the system:
  - processes (CPU usage)
  - memory (RAM and MMU)
  - device drivers (disk for example)
  - syscalls

- That processes usually do not execute at the same time

- That syscalls are all open, read, write operations

- That all user processes start with fork() and usually do exec() to open a new process instead of executing a copy of an existing process

- That most programs use syslog for logging

- That the concept of users exist for system adm  of permissions and limitations 
*** Chap 2 - Comandos básicos e hierarquia de diretórios
This chapter is mostly about concepts.

- That linux is a unix variant
- That bash is a variant of the bin/sh/
- That a terminal is an window to the shell interface
- Most commands assume . if the path does not start with / (it is not absolute)
- More than one option can be concatenated
- globbing does not work with julia Cmd!
- Env variables are a typical way of configuring the system
- Most commmand line editing kbds follow emacs
- Directories also have permissions. If you can ~read~ a dir it can be read but
  its files won't be acessable. For that the dir must be executable (~x~)
*** Chap 3 - Dispositivos
- device nodes are io interfaces which are presented as files to the user
- use ls /dev to take a looke at some devices of the system
  #+BEGIN_SRC shell
ls /dev  | head -10
  #+END_SRC

  #+RESULTS:
  | autofs          |
  | block           |
  | bsg             |
  | btrfs-control   |
  | bus             |
  | char            |
  | console         |
  | core            |
  | cpu             |
  | cpu_dma_latency |

- b c p s are block character pipe and socket devices
- *block devices* are fixed syze of information (sda1 for example)
- *character devices* work as  data streams
- *pipe devices* something similar to character devices
- *socket devices* are devices used for communication between processes 
- ls /sys/devices will give you a different look of the system devices
  #+BEGIN_SRC shell
ls /sys/devices
  #+END_SRC

  #+RESULTS:
  | breakpoint    |
  | cpu           |
  | cstate_core   |
  | cstate_pkg    |
  | i915          |
  | intel_pt      |
  | isa           |
  | kprobe        |
  | LNXSYSTM:00   |
  | msr           |
  | pci0000:00    |
  | platform      |
  | pnp0          |
  | power         |
  | software      |
  | system        |
  | tracepoint    |
  | uncore_arb    |
  | uncore_cbox_0 |
  | uncore_cbox_1 |
  | uncore_imc    |
  | uprobe        |
  | virtual       |

- devices with sd in their names are hard disk devices (memory)
- to list hard disks use lsscsi
  #+BEGIN_SRC shell
lsscsi
  #+END_SRC

  #+RESULTS:
  : [0:0:0:0]    disk    ATA      Lexar SSD        V4.7  /dev/sda
*** Chap 4 - Dicos e sistemas de arquivos
- partitions are subdivisions of the whole disk
- parted and gparted are apps to manage partitions
- to get a list of partitions use parted -l
- solid state disks vs hds is something akin to rams vs memory tapes
- *mkfs* is for creating a filesystem structure for a disk. ONLY do that for empty disks
- to visualize disks UUId use *blkid*
- to see the capacity and usage of disks use *df*
  #+BEGIN_SRC shell
df -mh | head -10
  #+END_SRC

  #+RESULTS:
  | Filesystem | Size | Used | Avail | Use% | Mounted                    | on |
  | udev       |    7 |    0 |     7 |   0% | /dev                       |    |
  | tmpfs      |    1 |    2 |     1 |   1% | /run                       |    |
  | /dev/sda1  | 469G | 146G |  299G |  33% | /                          |    |
  | tmpfs      |    7 | 227M |     7 |   3% | /dev/shm                   |    |
  | tmpfs      |    5 |    4 |     5 |   1% | /run/lock                  |    |
  | tmpfs      |    7 |    0 |     7 |   0% | /sys/fs/cgroup             |    |
  | /dev/loop2 |  61M |  61M |     0 | 100% | /snap/core20/634           |    |
  | /dev/loop3 | 256M | 256M |     0 | 100% | /snap/gnome-3-34-1804/36   |    |
  | /dev/loop0 |    2 |    2 |     0 | 100% | /snap/gnome-calculator/748 |    |


- *fsck* is the tool to check a disk, BUT ONLY use it in an unmounted disk
- if fsck is asking too much you are probably in trouble
- *fsck -n* verifies the disk without changing anything
- *swapping* is when part of the ram goes into disk to free ram 
*** Chap 7 - Configuracao do sistema: logging, hora do sistema ,tarefas em lote e usuarios
- The software to write scheduled processes is *cron*
- The form for ~crontab~ command is
  #+BEGIN_SRC text
min hour month-day month weekday command
  #+END_SRC
- To replace any of the fields with any min or hour and so on use ~*~
- More of one option can be set with ,
  #+BEGIN_SRC text
15 09 5,14  * *  command
  #+END_SRC
- crontab files live in "/var/spool/cron/crontabs"
- The easiest way to put into crontab is to put the commands in a file and then load the file with
  #+BEGIN_SRC text
crontab file
  #+END_SRC
- *fcron* is a more modern alternative to cron
- *at* is a one time cron alternative (atq and atrm check and remove jobs
  respectively).
- For more on crontab see [[https://www.digitalocean.com/community/tutorials/how-to-use-cron-to-automate-tasks-ubuntu-1804][How To Use Cron to Automate Tasks on Ubuntu 18.04 | DigitalOcean]]

*** Chap 8 - Observando mais de perto os processos e a utilizacao de recursos
- ~top~ is a useful command to display linux processes
- ~lsof~ lists open files and processes that are using them
- Processes are composed of threads. All processes start single-threaded, using the *main thread*.
- Threads are useful because they can be used "simultaneously", but with lower overhead than processes, while sharing resources. They are particularly useful in I/O.
- ~ps m~ shows thread information
- ~top -p pid~ will monitor an specific processes given its *pid*
- ~/usr/bin/time proc~ will show the time consumed by a proc
- There are three kinds of time \(\to\) user , system and elapsed (user+system are the most useful)
- *nice value (NI)* is the priority of a process in the kernel. One can tweak that with ~renice~ . This is particularly useful if you run heavy processes. Higher NIs mean less priority, so give the process a lower prioriti with *renice 20 pid*
- *load average* is the average number of processes ready to be executed at the moment. The command to see load average is ~uptime~ . It gives 1-5-15 minutes cpu usage information.
  #+BEGIN_SRC shell
uptime
  #+END_SRC

  #+RESULTS:
  | 15:59:18 up  1:12 | 1 user | load average: 0 | 38 | 0 | 48 | 0 | 61 |
- If the load average is always too high the system will start to do *thrashing* which is to *swap* memory. Not good, pay attetion to that.
- To verify memory status one uses the ~free~ (-ht options make it more readable ) command or sees /proc/meminfo
- the *page table* is a hash of addresses of processes to real memory addresses . If a memory address is not ready when it is called by a process it will cause a *page fault*
- ~vmstat~  is a program to visualize the frequency the kernel is swaping pages, the level of cpu and IO usage (aint easy to read ). ~pidstat~ is like vmstat but for specific processes 
*** Chap 9-10 - Entendendo a rede e sua configuracao / Aplicacoes e Servicos de Rede
- A *host* is any computer connected to a network
- Hosts that can transfer data between networks are *routers*
- Hosts + Router = *LAN* (Local Area Network)
- Computers share data in small portions called *packages* Packages are composed of *headers* and *payloads*.
- Headers contain id information such as hosts source destiny and about the protocol while payloads contain the actual data
- A network is composed of *layers* or *stack*. The layers are the following:
  1. *Application layer*
  2. *Transport layer*
  3. *Network Layer*
  4. *Physical Layer*
- The *application layer* contains the protocols apps and servers use to communicate. Among those protocols are:
  - *HTTP (Hypertext Transfer Protocol)*
  - *SSL (Secure socket layer)*
  - FTP (File Transfer Protocol)
- The *transport layer* verifies data integrity, how to split data into packages and so on. It uses two protocols to do so: *TCP* (Transmission Control Protocol) and *UDP* (User Datagram Protocol)
- The *network layer* defines how to transfer packages from a source host to a destiny host. The protocol it uses to do so is the *IP* (Internet Layer).
- The *physical layer* specifies how brute data goes through the modem or a ethernet and so on.
- Another name for router is *gateway*
- Every host has an *IP address*. That is, an identification in the internet protocol - which is the protocol for the network layers, which defines how packages are transferred between hosts. Obviously, to communicate with other host your computer ought to know the target IP address.
- ~ifconfig~ and ~ip~ are commands related to the network layer
- The *ICMP* (internet controlo message protocol) helps identify connectivity and routing problems  while the *DNS (Domain name service)* maps names to IP addresses
- ~ping~ is a network debugging tool
- ~host~ is a command to learn a domain IP address
- The internet is a *software* network. It lives on top of *physical networks*. One such physical network is the *Ethernet*.
- *NetworkManager* is the most famous app to deal with network configuration
- The TCP defines additional addresses to hosts on top of the IP.
- To see which TCP ports are open use ~netstat -nt~
- When we talk about client and server we are using TCP nomenclature. *client* is the process which makes the connection while *server* is the process which listens
- ~curl~ is an app which can be used to communicate using HTTP
- The *SSH (secure shell)* is the standard protocol for Unix *remote access*. *OpenSSH* is an open source implementation of the protocol, in it the client is ~ssh~ while the server is  ~sshd~ .
- To execute ssh one must have configuration files and host keys. Most linux distributions keep the configurations in the folder /etc/ssh
- OpenSSH includes the programs ~scp~ and ~sftp~ for file transfer between hosts.
- There are three kinds of network attacks:
  - Full compromising, through buffer overflow or accessing an user account and search for some *setuid*
    #+begin_quote
The Unix access rights flags setuid and setgid (short for "set user ID" and "set group ID")[1] allow users to run an executable with the file system permissions of the executable's owner or group respectively and to change behaviour in directories. They are often used to allow users on a computer system to run programs with temporarily elevated privileges in order to perform a specific task. While the assumed user id or group id privileges provided are not always elevated, at a minimum they are specific.

The flags,setuid and setgid, are needed for tasks that require different privileges than what the user is normally granted, such as the ability to alter system files or databases to change their login password
[[https://en.wikipedia.org/wiki/Setuid][setuid - Wikipedia]]
    #+end_quote
  - Denial of Service attacks (DoS)
  - Malwares (such as worms )
- *Sockets* are the interface used by processes to access the network through the kernel. Sockets are used for interprocess communication in the TCP layer 
*** Chap 11 - Introducao aos shell scripts
- Shebangs (~#!~) are put at the top of files we want to be run by some program.
  #+begin_quote
When a text file with a shebang is used as if it is an executable in a Unix-like operating system, the program loader mechanism parses the rest of the file's initial line as an interpreter directive.
[...]

When compared to the use of global association lists between file extensions and the interpreting applications, the interpreter directive method allows users to use interpreters not known at a global system level, and without administrator rights. [[https://en.wikipedia.org/wiki/Shebang_(Unix)][Shebang (Unix) - Wikipedia]]
  #+end_quote
  - ~#!/bin/bash~ or  ~#!/usr/bin/env~ python are examples
- ~chmod~ is the program to change *mode bits* of files ~chmod +rx scripts~ will allow the script to be read AND
   executed
- A *literal* is created with ~''~ and it tells the shell to not interpolate things inside the literal AND to treat it as a single object
- ~""~ will treat it as a single object BUT WILL substitute variables for values
- There are *special variables* in shell. They are:
  - ~$1, $2, ...~ which are command line parameters or script parameters. Lets say you define a foo.sh file:
    #+BEGIN_SRC bash
echo first argument $1
echo third argument $3
    #+END_SRC
    - If one runs
      #+BEGIN_SRC shell
./foo one two three
      #+END_SRC
    - It will output
      #+BEGIN_SRC text
first argument: one
third argument: three
      #+END_SRC
  - ~$#~ saves the number of parameters that were passed. Useful in loops
  - ~$@~ represents all the arguments of the script
  - ~$0~ represents the name of the script
  - ~$$~ represents the ID of the process
  - ~$?~ represents the output code
- If there is no error the *output code* is *0*
- Bash scripts use ~[]~ to encapsulate conditional expressions . Useful flags for it are -f (asks if it is a file), -a, -o.
- There are three kinds of tests: *file tests, string tests and arithmetic tests*:
- Examples of *unary* file tests are:
  - -e  it exists
  - -s  it is not empty
  - -s it is dir
  - -h it is  simbolic link
  - -b it is block
  - -c it is character
  - -p it is named pipe
  - -S it is socket
  - -r it is type read
  - -w it is type write
  - -x it is type executable
  - -u it is type setuid
  - -g it is type setgid
  - -k it is type sticky
- -nt and -ot are binary tests (newer than and older than)
- The equal sign is for string tests. use ~-eq~ for numeric equality
- There are many numeric test operators
- There is pattern matching with ~case~, ;; and esac
- And loops with ~for~ in do done
- Awk is an old fashioned scripting language
- One can encapsulate the value of the output of a program with ~$()~ (this is also used in make )
- ~basename~ removes extension and path from name
- ~()~ in a shell command creates a new encapsulated shell environment (*subshell*)
- To include another shell file in the script use ~.~ (. foo.sh includes it )

- ~shift~ pops the list of command line parameters
*** Chap 13 - Ambientes de usuario
- Linux installs most executables on /usr/bin. Symbolic links tend to live on /usr/local/bin
- He is againts *aliases*
  - *which* does not work well with aliases
  - they are not recognized by subshells and non-interactive shells
  - he recommends to write shell functions (create a sh file, make it executable, and put it on path)
- There are two kinds of shells: login shells and non login shells
- Login shells look for ~.bash_profile,.bash_login,.profile~
- Non login shells look for ~.bashrc~
  #+begin_quote

    If you open a shell or terminal (or switch to one), and it asks you to log in (Username? Password?) before it gives you a prompt, it's a login shell.
    If it doesn't (like gnome-terminal), and lets you use it straight away, it's a non-login shell.

If you are a normal user of Ubuntu Desktop, the only login shell is...your desktop (you type a password to get in, right ;)? Well, technically it's a login shell that starts a GUI, but that's getting in to jargon. And yes, it will read the settings in .profile

The only time you (a normal user) will probably see a login shell that looks like a login shell is if you are having some problem with your desktop and you switch to a virtual terminal with the Ctrl+Alt+F1 shortcut.

The other general cases for having a login shell include:

    *accessing your computer remotely via ssh (or connecting locally with ssh localhost)*
    simulating an initial login shell with bash -l (or sh -l)
    simulating an initial root login shell with sudo -i
        or sudo -u username -i for another non-root user
    authenticating as another non-root user with su - username (and their password)
    using the sudo login command to switch user

[[https://askubuntu.com/questions/155865/what-are-login-and-non-login-shells][bash - What are login and non-login shells? - Ask Ubuntu]]
  #+end_quote
- This means that most of the time one only changes their .bashrc. However, in my case, if I use *remote* shells then I will have to pay attention to .bash_profile
- As said before, to change the main shell of the system use ~chsh~
*** Chap 15 - Ferramentas de desenvolvimento
- An *object file* is sort of a precompiled object. They end with .o. The ~-c~ option of the compiler creates object files from source files
  #+BEGIN_SRC shell
cc -c main.c => main.o
  #+END_SRC
To create an *executable* from oject files one uses the -o flag
#+BEGIN_SRC shell
cc -o myprog main.o
#+END_SRC
- *Header files* are additional source files that tend to have type declarations and some library functions. They end with .h.
- Most installation problems are due to the compiler not finding header files.
- If there is a ~notfound.h~ that one has identified in /usr/jun/include one can point to its folder with the flag ~-I~ s.t.
  #+BEGIN_SRC shell
cc -c -I/usr/junk/include badinclude.c
  #+END_SRC
- It is not C compiler that looks for header files. It is its preprocessor. Commands to the preprocessor are written with ~#~ e.g. #include <notfound.h>.
- Another preprocessor commands are #define (which defines a macro ) and #ifdef, #if, #endif (which makes the preprocessor ignore if the conditional expression is false).
- The preprocessor app is ~cpp~ though it is probably more usual to use it in conjunction with the compiler with ~gcc -E~.
- Besides not finding headers it is possible that the compiler does not find libraries. The usual system place for libraries is /usr/lib . To solve it one must link it as with headers, but using the flag ~-L~ .
- There are two kinds of libraries:
  - *static libraries which end with .a*. When a program uses them it copies their binary into their binaries. Too much of this and the system is full.
  - *shared libraries end with .so*. They are not copied by the programs that use them, but are called upon when the programs are run. The obvious problem is that they must have a canonical path otherwise the programs won't work.
- The linker looks at /etc/ld.so.cache which is generated by running ldconfig -v after changing the list /etc/ld.so.conf , which contains paths to libraries. /lib and /usr/lib are not listed in it because they are already implicit.
- The linking of static libraries (above) is different from dynamic libraries.
- make is based on three ideas:
  - target
  - dependencies
  - rules
- The main principle of make is that targets ought to be synced with dependencies.
- Typical make targets are:
  - clean
  - distclean
  - install
  - test or check
  - all
- Lex and yacc are building blocks for programming languages
*** Chap 16 - INroducao a compilacaode software a partir de codigo fonte c
- Before extracting things it is better to taeke a look at it with ~tar tvf~ or ~tar ztvf~ . If there are files with names which are absolute paths *there is something wrong*
- Always look at the README and INSTALL files.
- If there are object files in the folder it is probable some sloppy job. Clean then with ~make clean~
- ~autotools~ is a make generator for cross compatility between OSs. It is based on three files:
  - configure
  - Makefile.in
  - config.h.in
- For the user what matters is that one runs ./configure, which will create a config.h and a (config.cache).
- The flow is, then, the following:
  1. ./configure
  2. make
  3. make check
  4. make -n install
  5. make install

- configure with --prefix=path will install the app on the this different path. The standard path for configure is */usr/local, /usr/local/bin for programs and /usr/local/lib* for libraries. That is, *this is the place things you installed yourself, not say apt-get (which will go to /usr/bin or /usr/lib)*
- For going to the end of the less script use ~G~ and for a reverse search use ~?~
- autotools has some typical make targets too:
  - clean
  - distclean
  - check
  - install-strip
- ~pkg-config~ is an interesting app to learn about pkgs (like flags, lib dependencies and ). Also, it is used *inside* make files so that we pass the necessary flags and so on.

  #+begin_quote
NAME
       pkg-config - Return metainformation about installed libraries

SYNOPSIS
       pkg-config  [--modversion]  [--version]  [--help]  [--atleast-pkgconfig-version=VERSION]  [--print-errors]  [--short-errors]
       [--silence-errors] [--errors-to-stdout] [--debug]  [--cflags]  [--libs]  [--libs-only-L]  [--libs-only-l]  [--cflags-only-I]
       [--libs-only-other] [--cflags-only-other] [--variable=VARIABLENAME] [--define-variable=VARIABLENAME=VARIABLEVALUE] [--print-
       variables] [--uninstalled] [--exists] [--atleast-version=VERSION] [--exact-version=VERSION] [--max-version=VERSION] [--vali‐
       date] [--list-all] [--print-provides] [--print-requires] [--print-requires-private] [LIBRARIES...]

DESCRIPTION
       The  pkg-config  program  is  used to retrieve information about installed libraries in the system.  It is typically used to
       compile and link against one or more libraries.  Here is a typical usage scenario in a Makefile:

       program: program.c
            cc program.c $(pkg-config --cflags --libs gnomeui)

  #+end_quote
- Pkgs which you installed yourself and are at /usr/local wont, obviously, be upgraded by your system.
- One way of looking for header files is by using the program ~apt-file~ (useful if there is a header linkage error )
** What are the main concepts of the text?

*** Chap 1 - Quadro geral
- abstraction
- level/layer
- hardware
- kernel
- process
- main memory
- CPU
- state
- image (physical organization of bits)
- process management
- context switch
- MMU
- syscalls
- fork()
- exec()
- log
- syslog
- user
  
*** Chap 2 - Comandos básicos e hierarquia de diretórios

- unix vs linux
- shell
  - Ctrl-D vs Ctrl-C in a terminal (finish stdin vs finish anything)
- *globbing*
- absolute path x relative path
- stream
- sdin, stdout, stderr
- shell variables (local to shell) vs environment variables (global to the
  system)
- command path
- PATH
- job control
- setuid
- symlinks
- bootloader

- echo
- cat
- ls
- cp
- mv
- *touch*
- rm (*-rf; -r is recursive while -f is force)*
- echo
- cd
- mkdir
- rmdir
- *grep*
- less
- pwd
- diff
- file
- find and locate
- head and  tail
- sort
- passwd
- chsh
- man (man -k keyword (sort for example))
- info (man for gnu stuff)
- | (redireaction, pipe)
- > (redirection, write)
- >> (redirection, append)
- ps (x, ax, u, w)
- kill
- (command ) &
- chmod
- gzip ; gunzip
- tar
  

*** Chap 3 - Dispositivos
- sysfs
- udev
- device nodes
- block, character, pipe and socket devices 
- uuid - universally unique identifier (something like a serial number)
- blkid

*** Chap 4 - Dicos e sistemas de arquivos
- swap
- partitions
- ssd

- parted gparted
- mkfs
- mount
*** Chap 7 - Configuracao do sistema: logging, hora do sistema ,tarefas em lote e usuarios
- cron
- crontab
*** Chap 8 - Observando mais de perto os processos e a utilizacao de recursos
- pid
- nice value
- main thread
- load average
- thrashing and swapping
- page table and page fault 


- top
- lsof
- /usr/bin/time
- renice
- uptime
- free
- vmstat
- pidstat
*** Chap 9-10 - Entendendo a rede e sua configuracao / Aplicacoes e Servicos de Rede


- host
- LAN
- router (gateway)
- network layers/stack
- packages (header,payload)
- Application layer
- Transport layer
- Network Layer
- Physical Layer
- HTTP
- SSL
- TCP
- UDP
- IP
- IP address
- ICMP
- DNS
- Ethernet
- SSH
- OpenSSH
- kinds of network attack
- Sockets


- NetworkManager
- ifconfig
- ip
- netstat -nt
- scp
- sftp

*** Chap 11 - Introducao aos shell scripts
*** Chap 13 _ Espacos do usuário
- /usr/bin vs /usr/local/bin
- login shells vs non login shells
- chsh

* Flashcards
** What is a linux layer? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T16:48:48Z
:FC_TYPE:  normal
:ID:       02d00e81-2551-4bf9-b302-67643de50bff
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T16:48:48Z |
:END:
*** Back
A classication of a component according to the position it occupies from user to hardware

** What is part of the hardware? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T16:49:59Z
:FC_TYPE:  normal
:ID:       f0ec2ab9-c669-4aa1-bdc6-98e1286edf22
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T16:49:59Z |
:END:
*** Back
CPU, RAM, Disks and Network ports
 - CPU = something the executes operations on memory, it reads and writes the memory
 - RAM = main memory, bunch of 1s and 0s

** What is an image? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:12:29Z
:FC_TYPE:  normal
:ID:       6aca609e-2fc1-4b1e-a08b-61ce71164178
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-15T18:36:10Z |
:END:
*** Back
A physical organization of bits

** What is responsibility of the kernel? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:14:25Z
:FC_TYPE:  normal
:ID:       3d180978-0b62-4f35-b97c-cf7000be53bb
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:14:25Z |
:END:
*** Back
It is in the middle of the OS layers. It manages 4 areas of the system:
  - processes (CPU usage) (initialization, pause, "retomada", ending)
    - context switch lives here
  - memory (RAM and MMU (access to virtual machines))
  - device drivers (disk for example)
  - syscalls
** What is context switch? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:16:00Z
:FC_TYPE:  normal
:ID:       74016d50-07d1-486b-981c-d96b54f6cf0b
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:16:00Z |
:END:
*** Back
The act of a process giving control of the cpu to another process.
** What are syscalls? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:17:28Z
:FC_TYPE:  normal
:ID:       c079240d-9610-4b13-ab83-cac1415a4c91
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:17:28Z |
:END:
*** Back
Processes that users can't do.  syscalls are all open, read, write operations. Two syscalls are particularly important: fork() and exec(). fork copies a process while exec initiates a process replacing the current process.

#+begin_quote
All user processes start with fork() and usually do exec() to open a new process instead of executing a copy of an existing process
#+end_quote

** What are logs? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:20:19Z
:FC_TYPE:  normal
:ID:       d3af9da1-72df-41d7-b8f3-8b9bc7aa25db
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:20:19Z |
:END:
*** Back
Diagnostics. The standard logging component for logging is ~syslog~.
** What is an user? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:21:50Z
:FC_TYPE:  normal
:ID:       483e0858-ee97-4658-83a0-0e72a84d6980
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:21:50Z |
:END:
*** Back
An entity that can execute processes and own files. This notion exists for sysadmins, users are the ones that one gives permission or limits access in the system. 

** What is the difference between Unix and Linux? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:26:14Z
:FC_TYPE:  normal
:ID:       6bb8590c-0cd3-47b5-89f1-be08aeb9b629
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:26:14Z |
:END:
*** Back
Linux is a variant of unix. Others variants are solaris and bsd.

** What is a shell? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:27:04Z
:FC_TYPE:  normal
:ID:       7c40e771-692d-406d-8e65-9f5bdb995d09
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:27:04Z |
:END:

*** Back
An interface for access to an operating system's services. The typical unix
shell is the Bourne shell (~bin/sh/~) while the most used shell for linux is
bash (bourne again shell).

A terminal is simply an window to the shell interface. 

** What is echo ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:31:46Z
:FC_TYPE:  normal
:ID:       83428a5d-a036-479c-b40d-747856d9f308
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:31:46Z |
:END:


*** Back
echo - display a line of text
#+BEGIN_SRC  elisp :results var
(man "echo")
#+END_SRC

#+RESULTS:
: #<buffer *Man echo*>

** What is cat? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:35:31Z
:FC_TYPE:  normal
:ID:       8d8250f3-ede6-45b8-8dfd-3e1c66a4340a
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:35:31Z |
:END:
*** Back
Bash command to open a file. See ~man cat~

** What are important ls options? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:43:51Z
:FC_TYPE:  normal
:ID:       583d4517-3da8-4752-9f55-ddcad4e90828
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:43:51Z |
:END:
*** Back

#+BEGIN_SRC shell
ls -l
#+END_SRC

which exhibits a full list
and

#+BEGIN_SRC shell
ls -F
#+END_SRC

which exhibits information about the file. 

** What are important ways of using cp? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:46:00Z
:FC_TYPE:  normal
:ID:       8da230ba-dfb1-4833-9445-232b81b10c07
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:46:00Z |
:END:
*** Back
#+BEGIN_SRC
cp f1 f2
#+END_SRC

To copy one f1 to f2 and

#+BEGIN_SRC
cp f1 fn dir
#+END_SRC

To copy all fs to a dir. The command ~mv~ follows a similar logic ! 

** What is the touch command? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:49:06Z
:FC_TYPE:  normal
:ID:       a5ccdca4-3ebe-4581-b154-b7393ed84923
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-19T13:38:33Z |
:END:
*** Back
It creates a file if it does not exist, but if it does it changes its timestamp
("it was touched"). Useful for makefiles. 

** What is an absolute path? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T18:54:55Z
:FC_TYPE:  normal
:ID:       8539f52b-34fa-472d-8357-6cad0cbc656d
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T18:54:55Z |
:END:
*** Back
One that begins with /. A relative path is one which does not begin with /.
** What is globbing? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T19:02:38Z
:FC_TYPE:  normal
:ID:       b7ce305f-0336-4808-acf7-68ae7b553864
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T19:02:38Z |
:END:
*** Back :ATTACH:
Pattern matching.

~*~ is used for pattern matching on characters.
- * matches on any combination of characters
- at* those that begin with at
- *at for those who end with at
- *at* for matching with all inputs that have any at

  #+BEGIN_SRC shell
ls 1*
  #+END_SRC
  #+RESULTS:
  : 182_zettelkasten_learning_method_simply_explained_youtube.org


  #+BEGIN_SRC  shell
ls *bbl
  #+END_SRC

  #+RESULTS:
  : 20200519143003-what_choice_situations_are_best_modeled_by_gt.bbl

#+BEGIN_SRC  shell
ls *emacs*
#+END_SRC

#+RESULTS:
| 20200516144415-doom_emacs.org                             |
| 20200516152744-learning_emacs.org                         |
| 20200704035904-emacs_keybindings.org                      |
| 20200706113517-emacs_configs.org                          |
| exploring_my_emacs_packages_projectile_philnewton_net.org |

For other globs see [[https://en.wikipedia.org/wiki/Glob_(programming)][glob (programming) - Wikipedia]]
[[attachment:_20200709_162328screenshot.png]]
** What is grep? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T19:31:29Z
:FC_TYPE:  normal
:ID:       22b58111-74f1-47b9-b1de-05cd24618cb9
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T19:31:29Z |
:END:
*** Back
A command that shows the lines of a file that correspond to an expression. grep
also accepts regex inputs.

#+BEGIN_SRC eshell
grep makefile why_use_make.org
#+END_SRC

#+RESULTS:
: - Modify any step in the workflow by editing the makefile, and regenerate files with minimal effort. The modular nature of makefiles means that each rule is (typically) self-contained. When starting new projects, recycle rules from earlier projects with a similar workflow.
: - Makefiles are testable. Even if you’re taking rigorous notes on how you built something, chances are a makefile is more reliable. A makefile won’t run if it’s missing a step; delete your generated files and rebuild from scratch to test. You can then be confident that you’ve fully captured your workflow.

It *works with globbing* so:
#+BEGIN_SRC eshell
grep makefile ./*
#+END_SRC

#+RESULTS:
: /usr/bin/grep: images/: Is a directory
: ward2014linux.org:("it was touched"). Useful for makefiles.
: why_use_make.org:- Modify any step in the workflow by editing the makefile, and regenerate files with minimal effort. The modular nature of makefiles means that each rule is (typically) self-contained. When starting new projects, recycle rules from earlier projects with a similar workflow.
: why_use_make.org:- Makefiles are testable. Even if you’re taking rigorous notes on how you built something, chances are a makefile is more reliable. A makefile won’t run if it’s missing a step; delete your generated files and rebuild from scratch to test. You can then be confident that you’ve fully captured your workflow.


Some useful options are -i and -v (seem ~man grep~)

** What is the less comand? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T19:41:24Z
:FC_TYPE:  normal
:ID:       2951c3ab-e8d0-47db-90df-d6b8d9548376
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T19:41:24Z |
:END:
*** Back
It paginates the terminal output one page at a time
** What is the bash file command ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T20:24:58Z
:FC_TYPE:  normal
:ID:       6bfb9579-fcfa-4896-ba28-9896451d343c
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-11T15:28:27Z |
:END:
*** Back
A bash command that tries to infer the type of the file. 
#+BEGIN_SRC shell
file why_use_make.org 
#+END_SRC

#+RESULTS:
| why_use_make.org: UTF-8 Unicode text | with very long lines |

** What are the head and tail bash commands? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T20:30:27Z
:FC_TYPE:  normal
:ID:       9e029e1c-2ea7-4e7a-b309-385c2142f9e0
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-08-19T20:56:11Z |
:END:
*** Back
The name are intuitive. The cool thing is that it works with any stream.
#+BEGIN_SRC eshell
ls | head -2
#+END_SRC

#+RESULTS:
: #20200519161456-what_is_an_equilibrium_refinement.org#
: 182_zettelkasten_learning_method_simply_explained_youtube.org

#+BEGIN_SRC shell
ls | tail
#+END_SRC

#+RESULTS:
| README.md                              |
| sep-game-theory.org                    |
| sep-reasons-just-vs-expl.org           |
| sep-social-choice.org                  |
| sep-voting-methods.org                 |
| shapiro2009state.org                   |
| the_many_types_of_types_mike_innes.org |
| Tideman_2011.org                       |
| ward2014linux.org                      |
| why_use_make.org                       |

#+BEGIN_SRC shell
ls | tail | sort -r
#+END_SRC

#+RESULTS:
| why_use_make.org                       |
| ward2014linux.org                      |
| Tideman_2011.org                       |
| the_many_types_of_types_mike_innes.org |
| shapiro2009state.org                   |
| sep-voting-methods.org                 |
| sep-social-choice.org                  |
| sep-reasons-just-vs-expl.org           |
| sep-game-theory.org                    |
| README.md                              |

** How do you change your password ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T20:39:43Z
:FC_TYPE:  normal
:ID:       40bbc7de-a6e1-4399-83f3-af32be25693f
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-24T15:10:29Z |
:END:
*** Back
With the command passwd.
** How do you change your standard shell? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T20:40:12Z
:FC_TYPE:  normal
:ID:       8f74553c-df72-4c41-9f0c-179e625c3785
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T20:40:12Z |
:END:
*** Back
With  the command chsh
** How do you access an env variable in bash ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T21:01:52Z
:FC_TYPE:  normal
:ID:       340a6784-5d70-4355-affe-ce8878d73bd5
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T21:01:52Z |
:END:

*** Back
With the dollar sign.
Example:
#+BEGIN_SRC  shell
echo $MATHEMATICA_HOME
#+END_SRC

#+RESULTS:
: /usr/local/Wolfram/WolframEngine/12.0
** What is PATH? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T21:06:02Z
:FC_TYPE:  normal
:ID:       f8782471-7793-49dc-a9e6-1365c3e94df8
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T21:06:02Z |
:END:
*** Back
It is the environment variable which saves the command path. The command path is a list of dirs which shell will look for a command. If we use say the command ~guile~ the shell will look for directories in path for an executable with this same name.

#+BEGIN_SRC shell
echo $PATH 
#+END_SRC

#+RESULTS:
: doom-emacs/bin/../bin:/home/mvmaciel/anaconda3/bin:/home/mvmaciel/anaconda3/condabin:/home/mvmaciel/.opam/default/bin:/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/mvmaciel/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:~/.cabal/bin/idris:~/joker-0.14.0-linux-amd64/joker

Most programs will live in usr/bin, but we also append the PATH with other
absolute paths we want the system to look for executables.

** How to look for keyword in linux manuals ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T21:43:38Z
:FC_TYPE:  normal
:ID:       a4f7c4fd-2427-4098-8cde-a1e85ba19595
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T21:43:38Z |
:END:
*** Back
using the -k option

#+BEGIN_SRC shell
man -k emacs  | head -3
#+END_SRC

#+RESULTS:
| ctags (1)            - generate tag file for Emacs | vi |
| ctags.emacs (1)      - generate tag file for Emacs | vi |
| ctags26 (1)          - generate tag file for Emacs | vi |

** What are stdout redirection commands? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T21:59:23Z
:FC_TYPE:  normal
:ID:       9bb2e7d2-77ec-4826-b1c1-c27d887e2d72
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T21:59:23Z |
:END:
*** Back
- > , which writes
- >>, which appends
- |, which pipes



  #+RESULTS:

** What are stdout and stderr file descriptors, and why this matters? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-09T22:08:06Z
:FC_TYPE:  normal
:ID:       977e106b-a51d-4b46-95d1-bf2dc4bc9b33
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-09T22:08:06Z |
:END:
*** Back
1 and 2 respectively. stderr file descriptor is used to redirect it to some
files.(2>) &1 is a reference to sdout file descriptor. When we combine the
two : #+begin_quote when you use 2>&1 you are basically saying “Redirect the stderr to the
same place we are redirecting the stdout”. And that’s why we can do something
like this to redirect both stdout and stderr to the same place
[[https://www.brianstorti.com/understanding-shell-script-idiom-redirect/][Understanding Shell Script's idiom: 2>&1]]
#+end_quote
** What are useful kill options? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T18:42:32Z
:FC_TYPE:  normal
:ID:       fd484817-3ad3-49f1-bbcb-ccc780d1eb1c
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-11T13:34:08Z |
:END:
*** Back
- kill -STOP pid or killall -STOP pid; will pause the process
- -CONT will restart the process
- -KILL to forcefully stop a process
- C-c in the terminal is the same as kill -INT pid-of-current-process
- C-z does something similar to -STOP in the current process
- To resume work write fg (move to foreground)
** What is job control? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T18:50:48Z
:FC_TYPE:  normal
:ID:       a090b6a9-bc4d-4a8f-9933-f00fe6cbd1f7
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    | 2.50 |   1 |     0.01 | 2020-07-11T13:34:26Z |
:END:
*** Back
When we kill, interrupt, resume and move processes to background or foreground. 
** Inbash, what (command _____) & does? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T19:26:25Z
:FC_TYPE:  normal
:ID:       ca0fcdd3-ddb3-4c61-926a-f0061cc2142c
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T19:26:25Z |
:END:
*** Back
it executes the command in background. it returns to you the PID.
** What is an archive mode? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T19:33:14Z
:FC_TYPE:  normal
:ID:       77326937-6511-449c-bf70-283f6cd1fd8d
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T19:33:14Z |
:END:
*** Back
It shows the type (normal (-), dir (d), the user permission (read or write or execute), the group permissions and the others permissions.
#+BEGIN_SRC shell
ls -lF | head -5
#+END_SRC

#+RESULTS:
| total      | 888 |          |          |      |     |    |       |                                                               |
| -rw-r--r-- |   1 | mvmaciel | mvmaciel |  365 | jul |  3 | 22:37 | 182_zettelkasten_learning_method_simply_explained_youtube.org |
| -rw-r--r-- |   1 | mvmaciel | mvmaciel | 2121 | mai | 19 | 11:27 | 20200516144415-doom_emacs.org                                 |
| -rw-r--r-- |   1 | mvmaciel | mvmaciel |   21 | mai | 16 | 18:29 | 20200516152708-programming.org                                |
| -rw-r--r-- |   1 | mvmaciel | mvmaciel | 3454 | jul | 10 | 11:03 | 20200516152744-learning_emacs.org                             |
      \(\uparrow\)
      is the mode . the first file is then a file , the user can read and write and groups and others can only read. 
#+BEGIN_SRC shell
ls -lF ~/ | tail -5
#+END_SRC

#+RESULTS:
| drwxr-xr-x | 7 | mvmaciel | mvmaciel |       4096 | abr | 18 | 00:52 | WolframLanguageForJupyter/              |
| -rw-r--r-- | 1 | mvmaciel | mvmaciel |      29570 | abr | 15 | 12:38 | WolframLanguageForJupyter-0.9.2.paclet  |
| -rwxr-xr-x | 1 | mvmaciel | mvmaciel | 1396632403 | abr | 18 | 03:59 | WolframPlayer_12.1.0_LINUX.sh*          |
| -rw-r--r-- | 1 | mvmaciel | mvmaciel |    2304864 | abr | 15 | 12:22 | WolframScript_12.1.0_LINUX64_x86_64.rpm |
| -rw-r--r-- | 1 | root     | root     |    2134228 | abr | 15 | 12:31 | wolframscript_1.3-2020032702_amd64.deb  |
shows examples with executables.

** How to change the permissions in linux? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T19:59:02Z
:FC_TYPE:  normal
:ID:       b489ca94-a466-4936-9132-b871736419fc
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T19:59:02Z |
:END:
*** Back
With the chmod commmand +r,+w, +x are equivalent to allow reading, writing and executing. We have to say who, however. o allows others while g allows group.

so ~chmod go+r file~ allows others and group to read a file.

** What is a symbolic link? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T20:17:28Z
:FC_TYPE:  normal
:ID:       a7adc151-0685-494b-afee-79066e7dc3bf
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T20:17:28Z |
:END:

*** Back
It is an alias that points to another file or dir. They are created with ~ln -s target linkname~. The option -s means they are soft links. Without it we would create a copy of the target (*hardlink*). Hardlinks point to the data, while softlinks to the name of the data.

- Deleting the target file of a symlink make it useless. The same cannot be said about hardlinks, since they preserve the data - are copies with a new name.

I believe this is the same as alias vs copy in julia. 
** What differentiates gzip from other zip programs ? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T20:26:45Z
:FC_TYPE:  normal
:ID:       a0999ec7-a513-4172-8bab-d556490194bf
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T20:26:45Z |
:END:
*** Back
It is a compression software not an archiving software. For that use ~tar~ (tar
cvf file.tar f1 f2 fn (for creating a tar) and tar xvf file.tar (for extracting
it)). There is also t option which is useful for inspecting a tar file and a z option for ziping unziping it while creating or extracting (tar
zcvf file.tar f1 f2 fn; creates and zips the files)

** Look at the simplified structure of linux dirs and say what each is about :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T21:05:56Z
:FC_TYPE:  normal
:ID:       14a10c67-20fe-4468-b83e-f212546a968b
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T21:05:56Z |
:END:
*** Back
[[file:~/Drive/Org/imgs/unixdirsh.png]]
For explanation see [[https://valters.eu/linux-directory-structure-explained-for-beginners/][Linux Directory Structure Explained for Beginners – Valters.EU]] 

** What is the purpose of a boot loader? :fc:
:PROPERTIES:
:FC_CREATED: 2020-07-10T21:09:21Z
:FC_TYPE:  normal
:ID:       b56f1646-03d3-4c4e-ac05-07199c039756
:END:
:REVIEW_DATA:
| position | ease | box | interval | due                  |
|----------+------+-----+----------+----------------------|
| front    |  2.5 |   0 |        0 | 2020-07-10T21:09:21Z |
:END:
*** Back
To load the kernel file, which is usually located on /vmlinuz or /boot/vmlinuz
